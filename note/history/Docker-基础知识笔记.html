<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker 基础知识笔记 | front-end</title>
    <meta name="description" content="a personal blog">
    <meta name="generator" content="VuePress 1.3.0">
    
    
    <link rel="preload" href="/front-end/assets/css/0.styles.59215ccd.css" as="style"><link rel="preload" href="/front-end/assets/js/app.a88e1da2.js" as="script"><link rel="preload" href="/front-end/assets/js/2.7828f7a4.js" as="script"><link rel="preload" href="/front-end/assets/js/22.5bbdb9a8.js" as="script"><link rel="prefetch" href="/front-end/assets/js/10.e35f737f.js"><link rel="prefetch" href="/front-end/assets/js/11.c4818444.js"><link rel="prefetch" href="/front-end/assets/js/12.adefcf89.js"><link rel="prefetch" href="/front-end/assets/js/13.289fbc8e.js"><link rel="prefetch" href="/front-end/assets/js/14.5b7a90db.js"><link rel="prefetch" href="/front-end/assets/js/15.960745b5.js"><link rel="prefetch" href="/front-end/assets/js/16.d9f6ac9b.js"><link rel="prefetch" href="/front-end/assets/js/17.a922242a.js"><link rel="prefetch" href="/front-end/assets/js/18.e519fb2e.js"><link rel="prefetch" href="/front-end/assets/js/19.1ce9712b.js"><link rel="prefetch" href="/front-end/assets/js/20.e4fb1dc3.js"><link rel="prefetch" href="/front-end/assets/js/21.f160d686.js"><link rel="prefetch" href="/front-end/assets/js/23.7816121a.js"><link rel="prefetch" href="/front-end/assets/js/24.9675e030.js"><link rel="prefetch" href="/front-end/assets/js/25.e7c3a1dc.js"><link rel="prefetch" href="/front-end/assets/js/26.9c61f899.js"><link rel="prefetch" href="/front-end/assets/js/27.959cc8fe.js"><link rel="prefetch" href="/front-end/assets/js/28.b5e23a0d.js"><link rel="prefetch" href="/front-end/assets/js/29.7b2c7d6f.js"><link rel="prefetch" href="/front-end/assets/js/3.03bc0eab.js"><link rel="prefetch" href="/front-end/assets/js/30.654517c9.js"><link rel="prefetch" href="/front-end/assets/js/31.408cc8f8.js"><link rel="prefetch" href="/front-end/assets/js/32.db5de3cc.js"><link rel="prefetch" href="/front-end/assets/js/33.72031c88.js"><link rel="prefetch" href="/front-end/assets/js/34.1eb8d601.js"><link rel="prefetch" href="/front-end/assets/js/35.a9e687c8.js"><link rel="prefetch" href="/front-end/assets/js/36.beddc298.js"><link rel="prefetch" href="/front-end/assets/js/37.4e100f8d.js"><link rel="prefetch" href="/front-end/assets/js/38.6eadbe92.js"><link rel="prefetch" href="/front-end/assets/js/39.38b7d565.js"><link rel="prefetch" href="/front-end/assets/js/4.7a69cc83.js"><link rel="prefetch" href="/front-end/assets/js/40.606e1d1b.js"><link rel="prefetch" href="/front-end/assets/js/41.b0bbf99f.js"><link rel="prefetch" href="/front-end/assets/js/42.45253c4f.js"><link rel="prefetch" href="/front-end/assets/js/43.8b24ef31.js"><link rel="prefetch" href="/front-end/assets/js/44.5bb8e60f.js"><link rel="prefetch" href="/front-end/assets/js/45.91df7ac4.js"><link rel="prefetch" href="/front-end/assets/js/46.8484468c.js"><link rel="prefetch" href="/front-end/assets/js/47.1776e82c.js"><link rel="prefetch" href="/front-end/assets/js/48.85fe29af.js"><link rel="prefetch" href="/front-end/assets/js/49.d65fdbfa.js"><link rel="prefetch" href="/front-end/assets/js/5.f2868031.js"><link rel="prefetch" href="/front-end/assets/js/50.8b8a1ffd.js"><link rel="prefetch" href="/front-end/assets/js/51.c8e2f737.js"><link rel="prefetch" href="/front-end/assets/js/52.db1a18eb.js"><link rel="prefetch" href="/front-end/assets/js/53.74a258ca.js"><link rel="prefetch" href="/front-end/assets/js/54.9cd7d75d.js"><link rel="prefetch" href="/front-end/assets/js/55.f1f6886c.js"><link rel="prefetch" href="/front-end/assets/js/56.c890af91.js"><link rel="prefetch" href="/front-end/assets/js/57.0c07b923.js"><link rel="prefetch" href="/front-end/assets/js/58.c5c82028.js"><link rel="prefetch" href="/front-end/assets/js/6.d7ef6033.js"><link rel="prefetch" href="/front-end/assets/js/7.1896c787.js"><link rel="prefetch" href="/front-end/assets/js/8.ae09b0b2.js"><link rel="prefetch" href="/front-end/assets/js/9.4c0a101a.js">
    <link rel="stylesheet" href="/front-end/assets/css/0.styles.59215ccd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/front-end/" class="home-link router-link-active"><!----> <span class="site-name">front-end</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/front-end/note/" class="nav-link router-link-active">
  笔记
</a></div><div class="nav-item"><a href="/front-end/engineering/" class="nav-link">
  工程化
</a></div> <a href="https://github.com/gyh9457/front-end/" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/front-end/note/" class="nav-link router-link-active">
  笔记
</a></div><div class="nav-item"><a href="/front-end/engineering/" class="nav-link">
  工程化
</a></div> <a href="https://github.com/gyh9457/front-end/" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front-end/note/webpack/" class="sidebar-link">webpack 基础</a></li><li><a href="/front-end/note/webpack/workflow.html" class="sidebar-link">运行流程</a></li><li><a href="/front-end/note/webpack/Tapable.html" class="sidebar-link">Tapable</a></li><li><a href="/front-end/note/webpack/loader.html" class="sidebar-link">编写一个 loader</a></li><li><a href="/front-end/note/webpack/plugin.html" class="sidebar-link">编写一个插件</a></li><li><a href="/front-end/note/webpack/minipack.html" class="sidebar-link">实现一个简单的 webpack</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>babel</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front-end/note/babel/" class="sidebar-link">babel 总结</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>历史笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/front-end/note/history/" class="sidebar-link">说明</a></li><li><a href="/front-end/note/history/Docker-基础知识笔记.html" class="active sidebar-link">Docker 基础知识笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front-end/note/history/Docker-基础知识笔记.html#docker-核心组成" class="sidebar-link">Docker 核心组成</a></li><li class="sidebar-sub-header"><a href="/front-end/note/history/Docker-基础知识笔记.html#centos-安装-docker" class="sidebar-link">CentOS 安装 docker</a></li><li class="sidebar-sub-header"><a href="/front-end/note/history/Docker-基础知识笔记.html#镜像与容器" class="sidebar-link">镜像与容器</a></li><li class="sidebar-sub-header"><a href="/front-end/note/history/Docker-基础知识笔记.html#相关名词解释" class="sidebar-link">相关名词解释</a></li></ul></li><li><a href="/front-end/note/history/React-Context-笔记.html" class="sidebar-link">React Context 笔记</a></li><li><a href="/front-end/note/history/向开源项目提交pr.html" class="sidebar-link">向开源项目提交pr</a></li><li><a href="/front-end/note/history/JS-设计模式.html" class="sidebar-link">JS 设计模式</a></li><li><a href="/front-end/note/history/webpack-chunkhash-稳定性问题.html" class="sidebar-link">webpack chunkhash 稳定性问题</a></li><li><a href="/front-end/note/history/创建一个-React-组件.html" class="sidebar-link">创建一个 React 组件</a></li><li><a href="/front-end/note/history/Some-Questions.html" class="sidebar-link">Some Questions</a></li><li><a href="/front-end/note/history/WebSockets小记.html" class="sidebar-link">WebSockets小记</a></li><li><a href="/front-end/note/history/前端路由.html" class="sidebar-link">前端路由</a></li><li><a href="/front-end/note/history/Vue-js内部运行机制.html" class="sidebar-link">《剖析Vue.js内部运行机制》笔记</a></li><li><a href="/front-end/note/history/项目模板总结.html" class="sidebar-link">项目模板总结</a></li><li><a href="/front-end/note/history/控制audio播放进度的实现.html" class="sidebar-link">控制audio播放进度的实现</a></li><li><a href="/front-end/note/history/Vue原理基础.html" class="sidebar-link">Vue原理基础</a></li><li><a href="/front-end/note/history/CSS布局.html" class="sidebar-link">CSS布局</a></li><li><a href="/front-end/note/history/Web-Sql-笔记.html" class="sidebar-link">Web Sql 笔记</a></li><li><a href="/front-end/note/history/使用Object-prototype-toString-call来检测对象类型.html" class="sidebar-link">使用Object.prototype.toString.call来检测对象类型</a></li><li><a href="/front-end/note/history/中文乱码问题解决.html" class="sidebar-link">中文乱码问题解决</a></li><li><a href="/front-end/note/history/Babel基础.html" class="sidebar-link">Babel基础</a></li><li><a href="/front-end/note/history/使用react-native-sound遇到的问题.html" class="sidebar-link">使用react-native-sound遇到的问题</a></li><li><a href="/front-end/note/history/ReactNative-原生与JS交互.html" class="sidebar-link">ReactNative 原生与JS交互</a></li><li><a href="/front-end/note/history/ReactNative调试.html" class="sidebar-link">ReactNative调试</a></li><li><a href="/front-end/note/history/H5拖拽简单应用.html" class="sidebar-link">H5拖拽简单应用</a></li><li><a href="/front-end/note/history/CentOS操作.html" class="sidebar-link">CentOS操作</a></li><li><a href="/front-end/note/history/git使用手册.html" class="sidebar-link">git使用手册</a></li><li><a href="/front-end/note/history/vue开发环境跨域问题.html" class="sidebar-link">vue开发环境跨域问题</a></li><li><a href="/front-end/note/history/Fiddler抓取ONE数据.html" class="sidebar-link">Fiddler抓取ONE数据</a></li><li><a href="/front-end/note/history/了解浏览器内核.html" class="sidebar-link">了解浏览器内核</a></li><li><a href="/front-end/note/history/前端跨域问题.html" class="sidebar-link">前端跨域问题</a></li><li><a href="/front-end/note/history/mvvm双向绑定实现原理.html" class="sidebar-link">mvvm双向绑定实现原理</a></li><li><a href="/front-end/note/history/云主机上部署Node-js应用.html" class="sidebar-link">云主机上部署Node.js应用</a></li><li><a href="/front-end/note/history/云主机上Nginx静态网站.html" class="sidebar-link">云主机上Nginx静态网站</a></li><li><a href="/front-end/note/history/vue打包发布文件无法显示问题.html" class="sidebar-link">vue打包发布文件无法显示问题</a></li><li><a href="/front-end/note/history/JavaScript面向对象编程指南学习笔记.html" class="sidebar-link">JavaScript面向对象编程指南学习笔记</a></li><li><a href="/front-end/note/history/CommonJS.html" class="sidebar-link">CommonJS</a></li><li><a href="/front-end/note/history/CMD规范.html" class="sidebar-link">CMD规范</a></li><li><a href="/front-end/note/history/AMD规范.html" class="sidebar-link">AMD规范</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="docker-核心组成"><a href="#docker-核心组成" class="header-anchor">#</a> Docker 核心组成</h2> <h3 id="四大组成对象"><a href="#四大组成对象" class="header-anchor">#</a> 四大组成对象</h3> <ol><li>镜像 (Image) 可以理解为一个只读的文件包，里面包含了 <code>虚拟环境运行最原始文件系统的内容</code>。</li> <li>容器 (Container) 指 <code>隔离出来的虚拟环境</code>。</li> <li>网络 (NetWork)</li> <li>数据卷 (Volume) <code>进行数据共享或持久化的文件或目录</code>。</li></ol> <h3 id="docker-engine"><a href="#docker-engine" class="header-anchor">#</a> Docker Engine</h3> <p><code>Docker Engine</code> 是一款软件，由多个独立软件所组成，里面最核心的是 <code>docker daemon</code> 和 <code>docker CLI</code>。</p> <p><code>docker daemon</code> 提供容器管理、应用编排、镜像分发等功能，通常以服务的形式运行以便静默的提供这些功能，所以通常称之为 <code>docker 服务</code>。</p> <p><code>docker daemon</code> 对外暴露了一套 <code>RESTful API</code> ，通过这套 API 可以对其中运行的容器和其它资源进行管理。<code>docker CLI</code> 正是操作这些 API 的工具。</p> <h2 id="centos-安装-docker"><a href="#centos-安装-docker" class="header-anchor">#</a> CentOS 安装 docker</h2> <div class="language-sh extra-class"><pre class="language-sh"><code>  yum <span class="token function">install</span> yum-utils device-mapper-persistent-data lvm2

  yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo

  yum <span class="token function">install</span> docker-ce

  systemctl <span class="token builtin class-name">enable</span> docker // 服务开机自启动

  systemctl start docker // 启动 docker 服务

  systemctl restart docker // 重启

  docker version // 版本信息

  docker info // docker 信息

  docker images // 查看镜像信息

  docker search <span class="token punctuation">[</span>image<span class="token punctuation">]</span> // 搜索镜像

  docker inspect <span class="token punctuation">[</span>docker 对象<span class="token punctuation">]</span> // 查看 docker 对象的详细信息，如镜像、容器等。

  docker rmi <span class="token punctuation">[</span>镜像名或镜像ID<span class="token punctuation">]</span> // 删除镜像

  docker create --name <span class="token punctuation">[</span>容器名<span class="token punctuation">]</span> <span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span> // 创建镜像 --name 可选

  docker start <span class="token punctuation">[</span>容器名<span class="token punctuation">]</span> // 启动容器

  docker run --name <span class="token punctuation">[</span>容器名<span class="token punctuation">]</span> -d <span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span> // 合并 create start 两个命令 -d 使启动后程序与控制台分离

  docker <span class="token function">ps</span> -a // 容器列表

  docker stop <span class="token punctuation">[</span>容器名<span class="token punctuation">]</span> // 停止容器 容器内部修改和沙盒环境还是存在

  docker <span class="token function">rm</span> <span class="token punctuation">[</span>镜像名<span class="token punctuation">]</span> // 删除容器 -f 强制删除

  docker <span class="token builtin class-name">exec</span> // 让容器执行命令

  docker <span class="token builtin class-name">exec</span> -it <span class="token punctuation">[</span>容器名<span class="token punctuation">]</span> <span class="token function">bash</span> // 开启容器的 Bash，从而进入容器进行控制 -i 保持输入流，保证正确识别命令 -t 启用伪终端

  docker attach <span class="token punctuation">[</span>容器名<span class="token punctuation">]</span> // 将当前输入输出流连接到指定的容器上
</code></pre></div><p>设置国内镜像源：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>  // etc/docker/daemon.json
  <span class="token punctuation">{</span>
    <span class="token string">&quot;registry-mirrors&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>
        <span class="token string">&quot;https://registry.docker-cn.com&quot;</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
</code></pre></div><h2 id="镜像与容器"><a href="#镜像与容器" class="header-anchor">#</a> 镜像与容器</h2> <h3 id="镜像的命名"><a href="#镜像的命名" class="header-anchor">#</a> 镜像的命名</h3> <ol><li>username 主要用于识别上传镜像的不同用户，与 <code>Github</code> 的用户空间类似。</li> <li>repository 主要用于识别镜像的内容，形成对镜像的表意描述。</li> <li>tag 主要用于表示镜像的版本，方便区分镜像内容的不同细节。</li></ol> <h3 id="容器的几个核心状态"><a href="#容器的几个核心状态" class="header-anchor">#</a> 容器的几个核心状态</h3> <ol><li>Created 容器已创建，资源准备就绪。</li> <li>Running 容器正在运行。</li> <li>Paused 容器已暂停。</li> <li>Stopped 容器停止，占用的资源及沙盒环境依然存在，只是应用程序停止。</li> <li>Deleted 容器已删除，占用资源及存储在 <code>docker</code> 中的管理信息都已释放和移除。</li></ol> <p><img src="https://user-gold-cdn.xitu.io/2018/9/17/165e53743e730432?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Request"></p> <h3 id="容器网络模型-container-network-model"><a href="#容器网络模型-container-network-model" class="header-anchor">#</a> 容器网络模型 ( Container Network Model)</h3> <p>在 <code>Docker</code> 网络中，有三个比较核心的概念，也就是 <code>沙盒 Sandbox</code>，<code>网络 Network</code>，<code>端点 Endpoint</code>。</p> <p><code>沙盒</code>提供了容器的虚拟网络栈，也就是端口套接字、IP路由表、防火墙等内容。其实现隔离了容器网络与宿主机网络，形成了完全独立的容器网络环境。</p> <p><code>网络</code>可以理解为 <code>Docker</code> 内部的虚拟子网，网络内的参与者相互可见并能够进行通讯，<code>Docker</code> 的这种虚拟网络也是与宿主机网络存在隔离关系的，其目的主要是形成容器间的安全通讯环境。</p> <p><code>端点</code>是位于容器或网络隔离墙之上的洞，其主要目的是形成一个可以控制的突破封闭的网络环境的出入口，当容器的端点与网络的端点形成配对后，就如同在这两者之间搭建了桥梁，便能够进行数据传输了。</p> <p>处于不同网络之中的容器无法互联。</p> <div class="language-bash extra-class"><pre class="language-bash"><code>  // 容器互联
  docker run -d --name mysql -e <span class="token assign-left variable">MYSQL_RANDOM_ROOT_PASSWORD</span><span class="token operator">=</span>yes mysql
  docker run -d --name webapp --link mysql webapp:latest

  String url <span class="token operator">=</span> <span class="token string">&quot;jdbc:mysql://mysql:3306/webapp&quot;</span><span class="token punctuation">;</span> // jdbc 连接

  docker run -d --name mysql -e <span class="token assign-left variable">MYSQL_RANDOM_ROOT_PASSWORD</span><span class="token operator">=</span>yes --expose <span class="token number">13306</span> --expose <span class="token number">23306</span> mysql:5.7 // --export 暴露端口

  // 通过别名连接
  docker run -d --name webapp --link mysql:database webapp:latest // --link <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span><span class="token operator">&lt;</span>alias<span class="token operator">&gt;</span>

  String url <span class="token operator">=</span> <span class="token string">&quot;jdbc:mysql://database:3306/webapp&quot;</span><span class="token punctuation">;</span>

  // 创建网络
  // 默认创建一个 bridge 网络，没有指定容器网络时都会连接到其中
  docker network create -d bridge individual // -d 指定网络驱动类型
  
  docker <span class="token function">ls</span> // 查看网络

  docker run -d --name mysql -e <span class="token assign-left variable">MYSQL_RANDOM_ROOT_PASSWORD</span><span class="token operator">=</span>yes --network individual mysql:5.7 // --network 指定网络

  // 端口映射 将容器的端口映射到宿主机上
  // -p <span class="token operator">&lt;</span>ip<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>host-port<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>container-port<span class="token operator">&gt;</span> ip为宿主操作系统的兼容ip，默认 <span class="token number">0.0</span>.0.0
  docker run -d --name nginx -p <span class="token number">80</span>:80 -p <span class="token number">443</span>:443 nginx:1.12
</code></pre></div><h3 id="管理和存储数据"><a href="#管理和存储数据" class="header-anchor">#</a> 管理和存储数据</h3> <p><code>Docker</code> 容器文件系统基于 <code>UnionFS</code>，由于 <code>UnionFS</code> 支持挂载不同类型的文件系统到统一的目录结构中，所以我们只需要将宿主操作系统中，文件系统里的文件或目录挂载到容器中，便能够让容器内外共享这个文件。通过这种方式互通容器内外的文件，那么文件数据持久化和操作容器内文件的问题就解决了。</p> <p><code>Docker</code> 提供三种适用于不同场景的文件系统挂载方式。</p> <ol><li>Bind Mount</li> <li>Volume</li> <li>Tmpfs Mount</li></ol> <div class="language-sh extra-class"><pre class="language-sh"><code>  // 挂载文件到容器
  // -v <span class="token operator">&lt;</span>host-path<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>container-path<span class="token operator">&gt;</span>
  docker run -d --name nginx -v /webapp/html:/usr/share/nginx/html:ro nginx:1.12

  // 临时挂载
  docker run -d --name webapp --tmpfs /webapp/cache webapp:latest // 无需指定内容位置，只指定挂载到容器内的目录

  // 使用数据卷 <span class="token punctuation">(</span>Volumn<span class="token punctuation">)</span>
  // 无需只调数据存储在宿主机的哪个地方
  // 只需给定容器中的哪个目录会被挂载
  docker run -d --name webapp -v /webapp/storage webapp:latest

  // -v <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>container-path<span class="token operator">&gt;</span> 命名数据卷
  docker run -d --name webapp -v appdata:/webapp/storage webapp:latest

  // 共用数据卷
  docker run -d --name webapp -v html:/webapp/html webapp:latest
  docker run -d --name nginx -v html:/usr/share/nginx/html:ro nginx:1.12

  // 创建数据卷
  docker volumn create <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span>

  docker volumn <span class="token function">ls</span> // 列表

  // 删除数据卷
  docker volumn <span class="token function">rm</span> <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span>

  docker <span class="token function">rm</span> -v <span class="token operator">&lt;</span>container name<span class="token operator">&gt;</span> // 删除容器时删除关联的数据卷

  docker volumn prune // 删除没有被引用的数据卷
  
  // 数据卷容器
  docker run -d --name webapp --volumes-from appdata webapp:latest

  // 备份和迁移数据卷

  // --mount 执行挂载
  // 可以使用参数
  docker run -d --name webapp webapp:latest --mount <span class="token string">'type=volume,src=appdata,dst=/webapp/storage,volume-driver=local,volume-opt=type=nfs,volume-opt=device=&lt;nfs-server&gt;:&lt;nfs-path&gt;'</span> webapp:latest
</code></pre></div><h3 id="保存和共享镜像"><a href="#保存和共享镜像" class="header-anchor">#</a> 保存和共享镜像</h3> <p><code>Docker</code> 可以将容器中可读可写的沙盒环境持久化为一个镜像层，也就是把容器内的修改记录下来，保存为一个新的镜像。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>  docker commit -m <span class="token string">'message'</span> <span class="token operator">&lt;</span>容器名<span class="token operator">&gt;</span>

  docker commit -m <span class="token string">'message'</span> <span class="token operator">&lt;</span>容器名<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>镜像名<span class="token operator">&gt;</span> // 提交更改时指定镜像名

  // docker tag 为镜像命名
  docker tag <span class="token operator">&lt;</span>Image Id<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>Image Name<span class="token operator">&gt;</span>
  docker tag <span class="token operator">&lt;</span>old Image Name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>New Image Name<span class="token operator">&gt;</span> // 创建新命名，两个镜像名指向同一个镜像

  // 导出镜像
  docker save webapp:1.0 <span class="token operator">&gt;</span> webapp-1.0-tar

  docker save -o ./webapp-1.0.tar webapp:1.0 // -o 指定导入文件

  // 导入镜像
  docker load <span class="token operator">&lt;</span> webapp-1.0.tar
  docker load -i webapp-1.0.tar // 使用 -i 导入

  // 批量迁移镜像
  docker save -o ./images.tar image1 image2 image3

  // 导出容器
  docker <span class="token builtin class-name">export</span> -o ./webapp.tar <span class="token operator">&lt;</span>Container Name<span class="token operator">&gt;</span>

  // 导入容器
  // 并非直接导入容器，而是将容器运行时的内容以镜像导入
  docker <span class="token function">import</span> ./webapp.tar <span class="token operator">&lt;</span>Image Name<span class="token operator">&gt;</span>
</code></pre></div><p>除了直接以文件方式导入、导出镜像外，还可以将镜像上传到仓库，然后 <code>docker pull</code> 拉取镜像，实现共享。</p> <p><a href="https://docs.docker.com/docker-hub/repos/" target="_blank" rel="noopener noreferrer">docker-repos<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="使用-dockerfile-创建镜像"><a href="#使用-dockerfile-创建镜像" class="header-anchor">#</a> 使用 Dockerfile 创建镜像</h3> <p><code>Dockerfile</code> 是用于定义镜像自动化构建流程的配置文件。</p> <p><code>Dockerfile</code> 的指令简单分为五大类。</p> <ol><li>基础指令 用于定义新镜像的基础和性质。</li> <li>控制指令 是指导镜像构建的核心部分，用于描述镜像在构建过程中需要执行的命令。</li> <li>引入指令 用于将外部文件直接引入到构建镜像内部。</li> <li>执行指令 能够为基于镜像所创建的容器，指定在启动时需要执行的脚本或命令。</li> <li>配置指令 对镜像以及基于镜像所创建的容器，可以通过配置指令对其网络、用户等内容进行配置。</li></ol> <p>常用指令：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>  // FROM 指定基础镜像
  FROM <span class="token operator">&lt;</span>image<span class="token operator">&gt;</span> <span class="token punctuation">[</span>AS <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span><span class="token punctuation">]</span>
  FROM <span class="token operator">&lt;</span>image<span class="token operator">&gt;</span><span class="token punctuation">[</span>:<span class="token operator">&lt;</span>tag<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>AS <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span><span class="token punctuation">]</span>
  FROM <span class="token operator">&lt;</span>image<span class="token operator">&gt;</span><span class="token punctuation">[</span>@<span class="token operator">&lt;</span>digest<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>AS <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span><span class="token punctuation">]</span>

  // RUN 向控制台发送命令
  // 支持 <span class="token punctuation">\</span> 换行
  RUN <span class="token operator">&lt;</span>command<span class="token operator">&gt;</span>
  RUN <span class="token punctuation">[</span><span class="token string">&quot;executable&quot;</span>, <span class="token string">&quot;param1&quot;</span>, <span class="token string">&quot;param2&quot;</span><span class="token punctuation">]</span>

  // ENTRYPOINT <span class="token operator">&amp;&amp;</span> CMD
  // 指定命令，在容器启动时启动进程号为1的进程
  ENTRYPOINT <span class="token punctuation">[</span><span class="token string">&quot;executable&quot;</span>, <span class="token string">&quot;param1&quot;</span>, <span class="token string">&quot;param2&quot;</span><span class="token punctuation">]</span>
  ENTRYPOINT <span class="token builtin class-name">command</span> param1 param2

  CMD <span class="token punctuation">[</span><span class="token string">&quot;executable&quot;</span>,<span class="token string">&quot;param1&quot;</span>,<span class="token string">&quot;param2&quot;</span><span class="token punctuation">]</span>
  CMD <span class="token punctuation">[</span><span class="token string">&quot;param1&quot;</span>,<span class="token string">&quot;param2&quot;</span><span class="token punctuation">]</span>
  CMD <span class="token builtin class-name">command</span> param1 param2

  // EXPOSE 指定暴露的端口
  EXPOSE <span class="token operator">&lt;</span>port<span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>port<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>protocol<span class="token operator">&gt;</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>

  // VOLUME 定义基于此镜像的容器所自动建立的数据卷
  VOLUME <span class="token punctuation">[</span><span class="token string">&quot;/data&quot;</span><span class="token punctuation">]</span>

  // COPY <span class="token operator">&amp;&amp;</span> ADD
  // 从宿主机文件系统中拷贝内容到镜像里的文件系统中
  COPY <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>group<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>src<span class="token operator">&gt;</span><span class="token punctuation">..</span>. <span class="token operator">&lt;</span>dest<span class="token operator">&gt;</span>
  ADD <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>group<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>src<span class="token operator">&gt;</span><span class="token punctuation">..</span>. <span class="token operator">&lt;</span>dest<span class="token operator">&gt;</span>

  COPY <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>group<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">&quot;&lt;src&gt;&quot;</span>,<span class="token punctuation">..</span>. <span class="token string">&quot;&lt;dest&gt;&quot;</span><span class="token punctuation">]</span>
  ADD <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>group<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">&quot;&lt;src&gt;&quot;</span>,<span class="token punctuation">..</span>. <span class="token string">&quot;&lt;dest&gt;&quot;</span><span class="token punctuation">]</span>
</code></pre></div><p>构建镜像：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>  docker build <span class="token punctuation">[</span>构建环境目录<span class="token punctuation">]</span> // 默认在此目录下创建，在此目录下寻找 Dockerfile 文件

  // -t 指定新生成镜像名称
  // -f 指定 Dockerfile 文件路径
  docker build -t webapp:latest -f ./webapp/a.Dockerfile ./webapp
</code></pre></div><p>使用技巧：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>    // ARG 声明变量
    // <span class="token variable">${xxx}</span> 使用变量
    // docker --build-arg 传入变量
    docker build --build-arg <span class="token assign-left variable">TOMCAT_MAJOR</span><span class="token operator">=</span><span class="token number">8</span> --build-arg <span class="token assign-left variable">TOMCAT_VERSION</span><span class="token operator">=</span><span class="token number">8.0</span>.53 -t tomcat:8.0 ./tomcat

    // ENV arg_name arg_value
    // 定义环境变量
    // -e --env 修改环境变量的值
    docker run -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>my-secret-pw -d mysql:5.7

    // --no-cache 禁用构建缓存
    docker build --no-cache ./webapp
</code></pre></div><h3 id="docker-compose"><a href="#docker-compose" class="header-anchor">#</a> Docker Compose</h3> <p><code>Docker Compose</code> 多容器的定义和运行软件，将多个容器运行的方式和配置固化下来。</p> <p>使用步骤可以简化为三步：</p> <ol><li>如果需要的话，编写容器所需镜像的 <code>Dockerfile</code></li> <li>编写用于配置容器的 <code>docker-compose.yml</code></li> <li>使用 <code>docker-compose</code> 命令启动应用</li></ol> <div class="language-sh extra-class"><pre class="language-sh"><code>  // -f 指定 docker-compose 配置文件
  // -d 转入后台运行<span class="token punctuation">\</span>
  // -p 定义项目名称
  docker-compose -f ./compose/docker-compose.yml -p myapp up -d

  docker-compose down
</code></pre></div><h3 id="应用于服务化开发"><a href="#应用于服务化开发" class="header-anchor">#</a> 应用于服务化开发</h3> <p>需要搭建 <code>Overlay Network</code>，跨越物理主机的限制，让多个处于不同 <code>docker daemon</code> 实例中的容器连接到同一个网络，并且让这些容器感觉这个网络与其他类型的网络没有区别。从而实现服务间互连。</p> <p>可以使用 <code>Docker Swarm</code> 实现。</p> <p>在真实的服务部署里，通常是使用 <code>Docker Compose</code> 来的定义集群，通过 <code>Docker Swarm</code> 来部署集群。或者使用 <code>Kubernetes(k8s)</code>。<code>k8s</code> 与这两者的组合相比，功能更强大。</p> <h2 id="相关名词解释"><a href="#相关名词解释" class="header-anchor">#</a> 相关名词解释</h2> <h3 id="rpm"><a href="#rpm" class="header-anchor">#</a> RPM</h3> <p><code>RPM</code> 是 <code>Red-Hat Package Manager</code> (RPM包管理器) 的缩写，这一文件格式名称虽然打上了 <code>RedHat</code> 的标志，但是其原始设计理念是开放式的，可以算是公认的行业标准了。</p> <h3 id="yum"><a href="#yum" class="header-anchor">#</a> yum</h3> <p><code>Yum</code> 全称为 <code>Yellow dog Updater Modified</code>，是一个在 <code>Fedoral</code> 和 <code>RedHat</code> 以及 <code>CentOs</code> 中的 <code>Shell</code> 前端软件包管理器，基于 <code>RPM</code> 包管理，能够从指定的服务器自动下载 <code>RPM</code> 包并且安装，可以自动化处理依赖性关系，并且一次安装所有依赖的软件包，无须频繁地一次次下载、安装。</p> <h3 id="device-mapper-persistent-data-lvm2"><a href="#device-mapper-persistent-data-lvm2" class="header-anchor">#</a> device-mapper-persistent-data &amp;&amp; lvm2</h3> <p>用于存储设备映射 (<code>devicemapper</code>) 必须的两个软件包。</p> <h3 id="device-mapper"><a href="#device-mapper" class="header-anchor">#</a> Device mapper</h3> <p><code>devicemapper</code> 是内核中支持逻辑卷管理的通用设备映射机制，它为实现用于存储资源管理的块设备驱动提供了一个高度模块化的内核架构，它包包含三个重要的对象概念：<code>Mapped Device</code>，<code>Mapping Table</code>，<code>Target Device</code>。</p> <hr> <p><a href="https://juejin.im/book/5b7ba116e51d4556f30b476c" target="_blank" rel="noopener noreferrer">开发者必备的 Docker 实践指南<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2/24/2020, 1:11:55 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/front-end/note/history/" class="prev router-link-active">
        说明
      </a></span> <span class="next"><a href="/front-end/note/history/React-Context-笔记.html">
        React Context 笔记
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/front-end/assets/js/app.a88e1da2.js" defer></script><script src="/front-end/assets/js/2.7828f7a4.js" defer></script><script src="/front-end/assets/js/22.5bbdb9a8.js" defer></script>
  </body>
</html>
